# 微服务和Docker

## Docker是什么

Docker是`Go`语言编写的，一种具有`虚拟化`特性的`应用容器`引擎，可以理解为一种`更轻量级`的虚拟机。

`应用容器`可以视为软件供应链的集装箱，能够把`应用`需要的运行环境、缓存环境、数据库环境等等封装起来，以最简洁的方式支持应用运行，轻装上阵，因为其同系统`共享内核`所以性能相比`虚拟机`更佳。

> 简单来讲：`Docker`提供的是`应用`环境，`虚拟机`提供的是`系统`环境

## Docker的优势

- 应用可以打包部署到Docker后可以保证`应用`环境在各个阶段的`一致性`。方便部署，减少运维压力，让开发者更加方便的对应用进行 `开发、测试、部署`，让应用快速迭代，快速上线。
- Docker`资源占用少`，`资源利用率高`。因为Docker相比虚拟机而言是直接同宿主机硬件打交道，而虚拟机则是把宿主机的硬件部分也虚拟化了。
- Docker打包`简单`，打包后体积相对于虚拟机小很多，同时部署也是`一键部署`。
- Docker`启动速度`相当快，比虚拟机快了好几个量级，常规情况下启动时间是以秒为单位。

## Docker的使用场景

### 应用场景1

在CentOS 6下，我编译了一个so文件，该so文件依赖系统环境的同时依赖了一些动态链接库。

- 我将该so文件，提供给了同事A，同事A在它的Ubuntu系统上因为系统动态库版本不一样，环境有差异，无法运行。
- 我将该so文件，提供给了同事B，同事B在它的CentOS 7下因为系统动态库版本不一样，环境有差异，无法运行。
- 我将该so文件，提供给了同事B，同事B在它的CentOS 6下，虽然系统大版本一直了，但是因为没有下载部分依赖项，也无法运行。

Docker如何处理这个问题？

我将这个so文件需要的链接库、软件配置等信息打包到Docker中，提供给同事的是将Docker镜像， 同事只需要在其各自系统下安装一次Docker，就可以通过一个简单指令启动运行。

### 应用场景2

我需要在Linux下部署RabbitMQ，经过查阅资料我发现大体我需要进行如下步骤

1. 根据不同的系统版本，选择安装Erlang环境支持的一大堆库（RabbitMQ）
2. 安装Erlang
3. 下载RabbitMQ的安装包
4. 解压软件压缩包
5. 修改配置
6. 启动RabbitMQ，然后运行。

一大堆事情折腾的很累人

Docker如何解决，2行代码：

```shell
## 下载rabbitmq 镜像
docker pull docker.io/rabbitmq
## 启动
docker run -d --name rabbitmq \
--publish 5671:5671  --publish 5672:5672 --publish 4369:4369 --publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \
rabbitmq:management
```

> 下载 RabbitMQ镜像此部分操作其实都可以省略，Docker 会自动检查本地仓库是否存在镜像，如果没有镜像会从Docker Hub官方仓库进行下载。

## Docker同微服务结合

微服务开发阶段同普通开发一致，无变化。微服务开发完成后进入测试阶段时，结合Docker进行如下操作来将Docker同微服务应用进行结合。

1. 编写Docker部署脚本Dockerfile。
2. 利用编写好的Dockerfile进行镜像构建。
3. 启动镜像，进行测试。
4. 修改BUG
5. 重复2，3，4.
6. 服务通过Docker镜像上线。

## 无网环境中Docker更简单

在我们JG行业中，要将应用部署到服务上，需要在外网下载各种工具包后，在宿主机中单独部署JDK，配置环境变量，安装数据库等一些支撑软件，费事、费力还容易配置错误。

但是Docker制作成镜像后，运行所需的所有环境都被打包进了容器了，只需要在宿主机上安装Docker，后续便能保证运行，部署起来更加简单。



